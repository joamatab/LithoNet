##
# Generate random clips of contacts into a single GDSII file together with a file specifying the centers of clips 
# 

import os
import re
import sys
import json
#from PIL import Image
import time
import numpy as np
import math 
import gdspy
import cv2
from numpy.lib.function_base import flip

# add root directory of the project to path 
sys.path.append(os.path.join(os.path.dirname(__file__), "../../"))

"""
Parameter class 
"""
class Params (object): 
    """
    initialization 
    """
    def __init__(self):
        self.gdsFile = None # output GDSII file 
        self.gdsDatabaseUnit = 1e-3 # GDSII database unit in um 
        self.ssFile = None # spreadsheet file 
        self.layer = 0 # layer 
        self.cell = "TOP" # cell name 
        self.sizeArray = None # size (x, y) array of contacts in um 
        self.pitchArray = None # pitch (x, y) array of contacts in um 
        self.regionWidth = None # clip regionWidth in um 
        self.regionHeight = None # clip regionHeight in um 
        self.randomVariation = None # variation in um 
        self.randomSeed = 1000 # random seed 
        self.numClips = 1000 # number of patterns 
        self.nparrayWidth = 250 # resolution (pixel) of the output layout numpy array
        self.npFile = None # output layout nparray file
    """
    convert to json  
    """
    def toJson(self):
        data = dict()
        data['gdsFile'] = self.gdsFile
        data['gdsDatabaseUnit'] = self.gdsDatabaseUnit
        data['ssFile'] = self.ssFile
        data['layer'] = self.layer
        data['cell'] = self.cell
        data['sizeArray'] = self.sizeArray
        data['pitchArray'] = self.pitchArray
        data['regionWidth'] = self.regionWidth
        data['regionHeight'] = self.regionHeight
        data['randomVariation'] = self.randomVariation
        data['randomSeed'] = self.randomSeed
        data['numClips'] = self.numClips
        return data 
    """
    load form json 
    """
    def fromJson(self, data):
        if 'gdsFile' in data:
            self.gdsFile = data['gdsFile']
        if 'gdsDatabaseUnit' in data:
            self.gdsDatabaseUnit = float(data['gdsDatabaseUnit'])
        if 'ssFile' in data:
            self.ssFile = data['ssFile']
        if 'layer' in data:
            self.layer = data['layer']
        if 'cell' in data:
            self.cell = data['cell']
        if 'sizeArray' in data:
            self.sizeArray = data['sizeArray']
        if 'pitchArray' in data:
            self.pitchArray = data['pitchArray']
        if 'regionWidth' in data:
            self.regionWidth = float(data['regionWidth'])
        if 'regionHeight' in data:
            self.regionHeight = float(data['regionHeight'])
        if 'randomVariation' in data:
            self.randomVariation = float(data['randomVariation'])
        if 'randomSeed' in data:
            self.randomSeed = data['randomSeed']
        if 'numClips' in data:
            self.numClips = data['numClips']
        if 'nparrayWidth' in data:
            self.nparrayWidth = data['nparrayWidth']
        if 'npFile' in data:
            self.npFile = data['npFile']

    """
    dump to json file 
    """
    def dump(self, filename):
        with open(filename, 'w') as f:
            json.dump(self.toJson(), f)
    """
    load from json file 
    """
    def load(self, filename):
        with open(filename, 'r') as f:
            self.fromJson(json.load(f))
    """
    string 
    """
    def __str__(self):
        return json.dumps(self.toJson(), indent=4, separators=(',', ':'))
        #return str(self.toJson())
    """
    print 
    """
    def __repr__(self):
        return self.__str__()

"""
Generate random patterns 
"""
class RandomClip (object): 
    """
    initialization 
    """
    def __init__(self, params):
        self.params = params
        self.region = np.array([0, 0, params.regionWidth, params.regionHeight]) 
        self.numRowClips = int(math.sqrt(self.params.numClips)) # number of clips on a row 
        print("numRowClips = ", self.numRowClips)
        self.rowClipId = 0 # clip id on row 
        self.clipArray = [] # record all contacts and clips, each element contains [region, contacts, center contact] 
        self.numArrayClips = 0 # record how many clips generated by arrays, which will be used to generate random array patterns 
        self.numRandomArrayClips = 0 # record how many clips generated by random arrays 
        self.numRandomNoiseArrayClips = 0 # record how many clips generated by random noise arrays
        np.random.seed(params.randomSeed)
    """
    top API to generate random clips 
    """
    def __call__(self): 
        # generate array patterns 
        self.generateArrays(self.params.numClips/3)
        self.next(newRowFlag=True)
        print("after array pattens: numClips = ", len(self.clipArray))

        # generate random array patterns 
        self.generateRandomArrays(self.params.numClips*2/3)
        self.next(newRowFlag=True)
        print("after random array patterns: numClips = ", len(self.clipArray))

        # generate random array patterns 
        self.generateRandomNoiseArrays(self.params.numClips)
        self.next(newRowFlag=True)
        print("after random noise array patterns: numClips = ", len(self.clipArray))

        os.system("mkdir -p %s" % (os.path.dirname(self.params.gdsFile)))
        os.system("mkdir -p %s" % (os.path.dirname(self.params.npFile)))

        # write clip property file for the positions of each clip 
        content = "clipId\tcenterX\tcenterY\twidth\theight\tlayer\ttype\tcenterContactWidth\tcenterContactHeight\n"
        for index, clip in enumerate(self.clipArray): 
            region = clip[0]
            centerContact = clip[2]
            type = "unknown"
            if index < self.numArrayClips: 
                type = "array"
            elif index < self.numArrayClips+self.numRandomArrayClips: 
                type = "randomArray"
            elif index < self.numArrayClips+self.numRandomArrayClips+self.numRandomNoiseArrayClips: 
                type = "randomNoise"
            content += "%d\t%f\t%f\t%f\t%f\t%d\t%s\t%f\t%f\n" % (index, (region[0]+region[2])/2, (region[1]+region[3])/2, region[2]-region[0], region[3]-region[1], self.params.layer, type, 
                                                        centerContact[2]-centerContact[0], centerContact[3]-centerContact[1])
        with open(self.clipPropertyFile(), "w") as f: 
            f.write(content)

        # write spreadsheet ssFile 
        self.writeSpreadsheet()

        # write to GDSII 
        # 1. write a GDSII file containing all clips 
        cell = gdspy.Cell(self.params.cell)
        for index, clip in enumerate(self.clipArray): 
            for contact in clip[1]: 
                cell.add(gdspy.Rectangle(contact[:2], contact[2:], self.params.layer))
            # add clip region to GDSII 
            cell.add(gdspy.Rectangle(clip[0][:2], clip[0][2:], self.params.layer+1))
            # add clip region index to GDSII 
            cell.add(gdspy.Label("%d" % (index), position=[(clip[0][0]+clip[0][2])/2, (clip[0][1]+clip[0][3])/2], layer=self.params.layer+2))

        gdsii = gdspy.GdsLibrary("RandomClips", unit=1.0e-6, precision=self.params.gdsDatabaseUnit*1.0e-6)
        gdsii.add(cell)
        #gdsii.write_gds(str(self.params.gdsFile), unit=1.0e-6, precision=self.params.gdsDatabaseUnit*1.0e-6)
        gdsii.write_gds(str(self.params.gdsFile))

        # 2. write one GDSII file for each clip 
        for index, clip in enumerate(self.clipArray): 
            gdsii = gdspy.GdsLibrary("RandomClip%d" % (index), unit=1.0e-6, precision=self.params.gdsDatabaseUnit*1.0e-6)
            # must overwrite current_lirary, otherwise we cannot add new cell with the same name 
            gdspy.current_library = gdsii 
            cell = gdspy.Cell(self.params.cell)

            for contact in clip[1]: 
                cell.add(gdspy.Rectangle(contact[:2], contact[2:], self.params.layer))
                # print('contact: ', contact[:2], contact[2:])
            # add clip region to GDSII 
            cell.add(gdspy.Rectangle(clip[0][:2], clip[0][2:], self.params.layer+1))
            # print('clip region: ', clip[0][:2], clip[0][2:])

            gdsii.add(cell)
            #gdsii.write_gds(self.clipGdsFile(index), unit=1.0e-6, precision=self.params.gdsDatabaseUnit*1.0e-6)
            gdsii.write_gds(self.clipGdsFile(index))

        # Write to layout numpy arrays
        layout_dict = {}
        for index, clip in enumerate(self.clipArray):
            width = self.params.nparrayWidth # layout image width
            regionX, regionY = clip[0][0], clip[0][1] # start point of clip
            image = np.zeros((250, 250))
            for contact in clip[1]:
                # coordinates of the lower-left vertice
                v1 = (int(round((contact[0]-regionX)/self.params.regionWidth * width)),
                      int(round((contact[1]-regionY)/self.params.regionWidth * width)))
                # coordinates of the upper-right vertice
                v2 = (int(round((contact[2]-regionX)/self.params.regionWidth * width)),
                      int(round((contact[3]-regionY)/self.params.regionWidth * width)))
                # add a rectangle (filled with black) as contact
                image = cv2.rectangle(image, v1, v2, color=255, thickness=-1)        
                image_mirrored = cv2.flip(image, flipCode=0) # mirror the image vertically to match gds file
            layout_dict["{:04}".format(index)] = image_mirrored
        # save as a .npz file
        np.savez(self.params.npFile, **layout_dict)
        

    """
    return clip property file name
    """
    def clipPropertyFile(self): 
        return str(self.params.gdsFile).replace(".gds", ".txt")
    """
    return spreadsheet file name (ssFile)
    """
    def clipSpreadsheetFile(self): 
        if self.params.ssFile: 
            return self.params.ssFile 
        else: 
            return str(self.params.gdsFile).replace(".gds", ".ss")
    """
    return clip gds file name
    """
    def clipGdsFile(self, index): 
        return str(self.params.gdsFile).replace(".gds", ".%s.gds" % ('{:04}'.format(index)))

    """
    generate array patterns
    """
    def generateArrays(self, numClips): 
        for size, pitch in zip(self.params.sizeArray, self.params.pitchArray): 
            print("size = ", size)
            print("pitch = ", pitch)
            # maximum number of grids
            numGrids = (int((self.params.regionWidth-size[0])/pitch[0]), int((self.params.regionHeight-size[1])/pitch[1]))
            print("numGrids = ", numGrids)
            # enumerate all combination of grids 
            for numGridX in range(1, numGrids[0]): 
                stepX = numGridX*pitch[0]
                rangeX = (-int((self.params.regionWidth-size[0])/2/stepX), int((self.params.regionWidth-size[0])/2/stepX)+1)
                for numGridY in range(1, numGrids[1]): 
                    stepY = numGridY*pitch[1]
                    rangeY = (-int((self.params.regionHeight-size[1])/2/stepY), int((self.params.regionHeight-size[1])/2/stepY)+1)
                    #print "step = ", (numGridX, numGridY)
                    contactArray = []
                    cx = (self.region[0]+self.region[2])/2 # center of clip 
                    cy = (self.region[1]+self.region[3])/2 # center of clip 
                    centerContact = None
                    for ix in range(rangeX[0], rangeX[1]): 
                        x = cx+ix*stepX # center of contact 
                        for iy in range(rangeY[0], rangeY[1]): 
                            y = cy+iy*stepY # center of contact 
                            # collect contacts 
                            ll = np.array([x-size[0]/2, y-size[1]/2])
                            ur = np.array([x+size[0]/2, y+size[1]/2])
                            if ix == 0 and iy == 0:
                                centerContact = np.array([ll[0], ll[1], ur[0], ur[1]])
                            contactArray.append(np.array([ll[0], ll[1], ur[0], ur[1]]))
                            assert self.within(ll, self.region)
                            assert self.within(ur, self.region)
                    # add contacts to GDSII 
                    self.clipArray.append((self.region, contactArray, centerContact))
                    self.numArrayClips += 1
                    # clip region 
                    self.next(newRowFlag=True if rangeY[1]-rangeY[0] == 1 and rangeX[1]-rangeX[0] == 1 else False)

                    # avoid repeating the same patterns with single row or column 
                    if (rangeY[1]-rangeY[0] == 1 or len(self.clipArray) >= numClips): 
                        break 
                # avoid repeating the same patterns with single row or column 
                if (rangeX[1]-rangeX[0] == 1 or len(self.clipArray) >= numClips): 
                    break 
        self.next(newRowFlag=True)
    """
    generate random arrays with some contacts omitted from arrays 
    """
    def generateRandomArrays(self, numClips):
        numRandomCopies = int(round(float(numClips-len(self.clipArray))/self.numArrayClips))
        print("numRandomCopies = ", numRandomCopies)
        for size, pitch in zip(self.params.sizeArray, self.params.pitchArray): 
            print("size = ", size)
            print("pitch = ", pitch)
            # maximum number of grids
            numGrids = (int((self.params.regionWidth-size[0])/pitch[0]), int((self.params.regionHeight-size[1])/pitch[1]))
            print("numGrids = ", numGrids)
            # enumerate all combination of grids 
            for numGridX in range(1, numGrids[0]): 
                stepX = numGridX*pitch[0]
                rangeX = (-int((self.params.regionWidth-size[0])/2/stepX), int((self.params.regionWidth-size[0])/2/stepX)+1)
                for numGridY in range(1, numGrids[1]): 
                    stepY = numGridY*pitch[1]
                    rangeY = (-int((self.params.regionHeight-size[1])/2/stepY), int((self.params.regionHeight-size[1])/2/stepY)+1)
                    #print "step = ", (numGridX, numGridY)
                    for k in range(numRandomCopies): # random copies from one array clip 
                        contactArray = []
                        cx = (self.region[0]+self.region[2])/2 # center of clip 
                        cy = (self.region[1]+self.region[3])/2 # center of clip 
                        centerContact = None # contact in the center, which cannot be omitted 
                        for ix in range(rangeX[0], rangeX[1]): 
                            x = cx+ix*stepX # center of contact 
                            for iy in range(rangeY[0], rangeY[1]): 
                                y = cy+iy*stepY # center of contact 
                                # collect contacts 
                                ll = np.array([x-size[0]/2, y-size[1]/2])
                                ur = np.array([x+size[0]/2, y+size[1]/2])
                                if ix == 0 and iy == 0: # treat center contact specially 
                                    centerContact = np.array([ll[0], ll[1], ur[0], ur[1]])
                                else: # non-center contacts 
                                    contactArray.append(np.array([ll[0], ll[1], ur[0], ur[1]]))
                                assert self.within(ll, self.region)
                                assert self.within(ur, self.region)
                        # omit some contacts 
                        # number of remained contacts 
                        if len(contactArray) < 5: # skip few patterns
                            continue 
                        # random sampling with random size 
                        numRemain = np.random.randint(max(int(0.4*len(contactArray)), 1), int(math.floor(0.9*len(contactArray))))
                        sampleIndexArray = np.random.choice(np.arange(len(contactArray)), size=numRemain, replace=False)
                        randomContactArray = [contactArray[i] for i in sampleIndexArray]
                        # add center contact 
                        randomContactArray.append(centerContact) 
                        # add contacts to GDSII 
                        self.clipArray.append((self.region, randomContactArray, centerContact))
                        self.numRandomArrayClips += 1
                        # clip region 
                        self.next(newRowFlag=True if rangeY[1]-rangeY[0] == 1 and rangeX[1]-rangeX[0] == 1 else False)

                        if (len(self.clipArray) >= numClips): 
                            break 
                    # avoid repeating the same patterns with single row or column 
                    if (rangeY[1]-rangeY[0] == 1 or len(self.clipArray) >= numClips): 
                        break 
                # avoid repeating the same patterns with single row or column 
                if (rangeX[1]-rangeX[0] == 1 or len(self.clipArray) >= numClips): 
                    break 
        self.next(newRowFlag=True)
    """
    generate arrays with random noise 
    """
    def generateRandomNoiseArrays(self, numClips): 
        numRandomCopies = int(round(float(numClips-len(self.clipArray))/self.numArrayClips))
        print("numRandomCopies = ", numRandomCopies)
        for size, pitch in zip(self.params.sizeArray, self.params.pitchArray): 
            print("size = ", size)
            print("pitch = ", pitch) 
            # maximum number of grids
            numGrids = (int((self.params.regionWidth-size[0])/pitch[0]), int((self.params.regionHeight-size[1])/pitch[1]))
            print("numGrids = ", numGrids)
            # enumerate all combination of grids 
            for numGridX in range(1, numGrids[0]): 
                stepX = numGridX*pitch[0]
                rangeX = (-int((self.params.regionWidth-size[0])/2/stepX), int((self.params.regionWidth-size[0])/2/stepX)+1)
                for numGridY in range(1, numGrids[1]): 
                    stepY = numGridY*pitch[1]
                    rangeY = (-int((self.params.regionHeight-size[1])/2/stepY), int((self.params.regionHeight-size[1])/2/stepY)+1)
                    #print "step = ", (numGridX, numGridY)
                    for k in range(numRandomCopies): # random copies from one array clip 
                        contactArray = []
                        cx = (self.region[0]+self.region[2])/2 # center of clip 
                        cy = (self.region[1]+self.region[3])/2 # center of clip 
                        centerContact = None # contact in the center, which cannot be omitted 
                        for ix in range(rangeX[0], rangeX[1]): 
                            x = cx+ix*stepX # center of contact 
                            for iy in range(rangeY[0], rangeY[1]): 
                                y = cy+iy*stepY # center of contact 
                                # collect contacts 
                                ll = np.array([x-size[0]/2, y-size[1]/2])
                                ur = np.array([x+size[0]/2, y+size[1]/2])
                                if ix == 0 and iy == 0: # treat center contact specially 
                                    centerContact = np.array([ll[0], ll[1], ur[0], ur[1]])
                                else: # non-center contacts 
                                    contactArray.append(np.array([ll[0], ll[1], ur[0], ur[1]]))
                                assert self.within(ll, self.region)
                                assert self.within(ur, self.region)
                        # add noise to locations of contacts
                        noiseArray = np.random.normal(0, self.params.randomVariation, len(contactArray))
                        randomContactArray = [contactArray[i]+noiseArray[i] for i in range(len(contactArray))]
                        validArray = [True]*len(randomContactArray)
                        for i in range(len(randomContactArray)): 
                            if validArray[i]: 
                                if self.distance(randomContactArray[i], centerContact) < min(pitch[0], pitch[1])/2 or not self.within(randomContactArray[i][:2], self.region) or not self.within(randomContactArray[i][2:], self.region): # overlap with center contact, or out fo region  
                                    validArray[i] = False
                                else: 
                                    for j in range(len(randomContactArray)): 
                                        if i != j and validArray[j]: 
                                            if self.distance(randomContactArray[i], randomContactArray[j]) < min(pitch[0], pitch[1])/2: # two contacts have overlap 
                                                validArray[j] = False 
                        selectContactArray = [randomContactArray[i] for i in range(len(randomContactArray)) if validArray[i]]
                        if not selectContactArray: 
                            continue 
                        # add center contact 
                        selectContactArray.append(centerContact) 
                        # add contacts to GDSII 
                        self.clipArray.append((self.region, selectContactArray, centerContact))
                        self.numRandomNoiseArrayClips += 1
                        # clip region 
                        self.next(newRowFlag=True if rangeY[1]-rangeY[0] == 1 and rangeX[1]-rangeX[0] == 1 else False)

                        if (len(self.clipArray) >= numClips): 
                            break 
                    # avoid repeating the same patterns with single row or column 
                    if (rangeY[1]-rangeY[0] == 1 or len(self.clipArray) >= numClips): 
                        break 
                # avoid repeating the same patterns with single row or column 
                if (rangeX[1]-rangeX[0] == 1 or len(self.clipArray) >= numClips): 
                    break 
    """
    write spreadsheet file 
    """
    def writeSpreadsheet(self): 
        content = "# Struct\tRow\tCol\tGDSX\tGDSY\tLoc\tDrawn\tOther\tMeas\tWeight\n"
        for index, clip in enumerate(self.clipArray): 
            region = clip[0]
            centerContact = clip[2]
            type = "unknown"
            if index < self.numArrayClips: 
                type = "array"
            elif index < self.numArrayClips+self.numRandomArrayClips: 
                type = "randomArray"
            elif index < self.numArrayClips+self.numRandomArrayClips+self.numRandomNoiseArrayClips: 
                type = "randomNoise"
            name = "clip%s_w%d_h%d_%s" % ('{:04}'.format(index), int(round((centerContact[2]-centerContact[0])/self.params.gdsDatabaseUnit)), int(round((centerContact[3]-centerContact[1])/self.params.gdsDatabaseUnit)), type)
            xl = centerContact[0]
            yl = centerContact[1]
            xh = centerContact[2]
            yh = centerContact[3]
            cx = (xl+xh)/2
            cy = (yl+yh)/2
            # according to Calibre's format 
            # use left edge for CD of x direction 
            # use bottom edge for CD of y direction 
            content += "%s\t%d\t%d\t%f\t%f\t%d\t%f\t%s\t%f\t%f\n" % (name, 
                                                                    index*2, 0, # row and col seem not really matter 
                                                                    float(xl/self.params.gdsDatabaseUnit), float(cy/self.params.gdsDatabaseUnit), 
                                                                    0, 
                                                                    (xh-xl)/self.params.gdsDatabaseUnit, 
                                                                    "NA", 
                                                                    (xh-xl)/self.params.gdsDatabaseUnit, # use design target if we do not have measure values 
                                                                    1)
            content += "%s\t%d\t%d\t%f\t%f\t%d\t%f\t%s\t%f\t%f\n" % (name, 
                                                                    index*2+1, 0, # row and col seem not really matter 
                                                                    float(cx/self.params.gdsDatabaseUnit), float(yl/self.params.gdsDatabaseUnit), 
                                                                    0, 
                                                                    (yh-yl)/self.params.gdsDatabaseUnit, 
                                                                    "NA", 
                                                                    (yh-yl)/self.params.gdsDatabaseUnit, # use design target if we do not have measure values 
                                                                    1)
        with open(self.clipSpreadsheetFile(), "w") as f: 
            f.write(content)
    """
    go to next clip region
    """
    def next(self, newRowFlag): 
        # step between clips 
        step = (self.params.regionWidth*4, self.params.regionHeight*4)
        offsetY = self.region[1]
        if newRowFlag or self.rowClipId+1 >= self.numRowClips: 
            self.rowClipId = 0
            offsetY += step[1]
        else: 
            self.rowClipId += 1
        offsetX = self.rowClipId*step[0]

        self.region = np.array([offsetX, offsetY, offsetX+self.params.regionWidth, offsetY+self.params.regionHeight])
    """
    return true if a point is within a region
    """
    def within(self, point, region): 
        return region[0] <= point[0] and point[0] <= region[2] and region[1] <= point[1] and point[1] <= region[3]
    """
    return true if two rectangles have overlap 
    """
    def overlap(self, rect1, rect2): 
        return max(rect1[0], rect2[0]) <= min(rect1[2], rect2[2]) and max(rect1[1], rect2[1]) <= min(rect1[3], rect2[3])
    """
    return the euclidean distance between two rectangles, 0 if overlapped  
    """
    def distance(self, rect1, rect2): 
        dx = max(0, max(rect1[0], rect2[0])-min(rect1[2], rect2[2]))
        dy = max(0, max(rect1[1], rect2[1])-min(rect1[3], rect2[3]))
        return math.sqrt(float(dx*dx+dy*dy))


## Main
def main(params):
    tt = time.time()

    RandomClip(params)()

    print("elapsed Time (sec): {:.4f}".format(time.time()-tt))

if __name__ == "__main__":
    if len(sys.argv) < 2:
        print("input parameters in json format in required")
        exit() 
    paramsArray = []
    for i in range(1, len(sys.argv)):
        params = Params()
        params.load(sys.argv[i])
        paramsArray.append(params)
    print("parameters array = ", paramsArray)

    for params in paramsArray: 
        main(params)

